

const ZELDA2_TO_ASCII: [u8; 256] = [
// 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 00
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 10
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 20
0x00,0x00,0x2a,0x00,0x3f,0x00,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 30
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 40
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 50
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 60
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 70
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 80
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x00,  // 90
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // A0
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // B0
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2f,0x2e,   // C0
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44,0x45,0x46,  // D0
0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,  // E0
0x57,0x58,0x59,0x5a,0x20,0x20,0x2d,0x00,0x00,0x00,0x00,0x00,0x78,0x7c,0x5f,0x00,  // F0
];

const ASCII_TO_ZELDA2: [u8; 128] = [
// 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 00
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 10
0xf4,0x36,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x32,0x00,0x9c,0x00,0xcf,0xce,  // 20
0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0x00,0x00,0x00,0x00,0x00,0x34,  // 30
0x00,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,  // 40
0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf3,0x00,0xfd,0x00,0x00,0xfe,  // 50
0x00,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,  // 60
0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf3,0x00,0x00,0x00,0x00,0x00,  // 70
];

pub struct Text;

impl Text {
    pub fn from_zelda2(z: &[u8]) -> String {
        let mut s = String::new();
        for ch in z.iter() {
            let ch = ZELDA2_TO_ASCII[*ch as usize];
            if ch == 0 {
                s.push('?');
            } else {
                s.push(ch as char);
            }
        }
        s
    }

    pub fn to_zelda2(s: &str) -> Vec<u8> {
        let mut z: Vec<u8> = Vec::new();
        let err = ASCII_TO_ZELDA2['?' as usize];
        for ch in s.bytes() {
            let ch = if ch < 128 {
                let t = ASCII_TO_ZELDA2[ch as usize];
                if t == 0 { err } else { t }
            } else {
                err
            };
            z.push(ch);
        }
        z
    }

    pub fn validate(s: &str, maxlen: Option<usize>) -> String {
        let mut valid = String::new();
        let len = if let Some(maxlen) = maxlen {
            maxlen
        } else {
            s.len()
        };
        for (i, ch) in s.bytes().enumerate() {
            if i >= len {
                break;
            }
            let ch = if ch < 128 {
                ASCII_TO_ZELDA2[ch as usize]
            } else {
                0
            };
            let ch = ZELDA2_TO_ASCII[ch as usize];
            if ch == 0 {
                valid.push('?');
            } else {
                valid.push(ch as char);
            }
        }
        valid
    }
}
